<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<HTML>
  <HEAD>
    <META name="Author" content="john sadler">
    <META name="Description" content="Ficl - embedded scripting with object oriented programming">
    <META name="Keywords" content="scripting prototyping tcl OOP Forth interpreter C">

    <LINK media="screen" href="ficlstyle.css" type="text/css" rel="stylesheet">
<STYLE type="text/css">
    
</STYLE>

    <LINK rel="SHORTCUT ICON" href="ficl.ico">
    <TITLE>
      Ficl Glossary
    </TITLE>
  </HEAD>
  <BODY>
    <H1>
      <B>Ficl Glossary</B>
    </H1>
<SCRIPT language="javascript" src="ficlheader.js" type="text/javascript">
</SCRIPT>
    <DIV style="width:675px">
      <HR>
      <H2>
        <A name="extras"></A>Ficl extras
      </H2>
      <H3>
        <A name="exnumber"></A>Number syntax
      </H3>
      You can precede a number with "0x", as in C, and it will be interpreted as a hex value regardless of the value of <CODE>BASE</CODE>. Likewise, numbers prefixed with "0d" will be interpreted as
      decimal values. Example: 
<PRE>
ok&gt; decimal 123 . cr
123
ok&gt; 0x123 . cr
291
ok&gt; 0x123 x. cr
123
</PRE>
      Note: ficl2.05 and later - this behavior is controlled by the <A href="ficl_parse.html">prefix parser</A> defined in <CODE>prefix.c</CODE>. You can add other prefixes by defining handlers for
      them in ficl or C. 
      <H3>
        <A name="exsearch"></A> The <CODE>SEARCH</CODE> wordset and Ficl extensions
      </H3>
      <P>
        Ficl implements many of the search order words in terms of two primitives called <CODE><A href="#tosearch">&gt;SEARCH</A></CODE> and <CODE><A href="#searchfrom">SEARCH&gt;</A></CODE>. As
        their names suggest (assuming you're familiar with Forth), they push and pop the search order stack.
      </P>
      <P>
        The standard does not appear to specify any conditions under which the search order is reset to a sane state. Ficl resets the search order to its default state whenever <TT>ABORT</TT>
        happens. This includes stack underflows and overflows. <TT>QUIT</TT> does not affect the search order. The minimum search order (set by <TT>ONLY</TT>) is equivalent to
      </P>
<PRE>
FORTH-WORDLIST 1 SET-ORDER
</PRE>
      <P>
        There is a default maximum of 16 wordlists in the search order. This can be changed by redefining FICL_DEFAULT_VOCS (declared in sysdep.h).
      </P>
      <P>
        <B>Note</B>: Ficl resets the search order whenever it does <TT>ABORT</TT>. If you don't like this behavior, just comment out the dictResetSearchOrder() lines in ficlExec().
      </P>
      <DL>
        <DT>
          <A name="tosearch"></A><CODE>&gt;search ( wid -- )</CODE>
        </DT>
        <DD>
          Push <TT>wid</TT> onto the search order. Many of the other search order words are written in terms of the <TT>SEARCH&gt;</TT> and <TT>&gt;SEARCH</TT> primitives. This word can be defined in
          ANS Forth as follows
        </DD>
        <DD>
          <TT>: &gt;search&nbsp;&nbsp; &gt;r get-order 1+ r&gt; swap set-order ;</TT>
        </DD>
        <DT>
          <A name="searchfrom"></A><TT>search&gt;&nbsp;&nbsp; ( -- wid )</TT>
        </DT>
        <DD>
          Pop <TT>wid</TT> off the search order (can be coded in ANS Forth as&nbsp;<TT>: search&gt;&nbsp; get-order nip 1- set-order ;</TT> )
        </DD>
        <DT>
          <A name="ficlsetcurrent"></A><TT>ficl-set-current&nbsp;&nbsp; ( wid -- old-wid )</TT>
        </DT>
        <DD>
          Set wid as compile wordlist, leaving the previous compile wordlist on the stack
        </DD>
        <DT>
          <A name="ficlvocabulary"></A><TT>ficl-vocabulary&nbsp;&nbsp; ( nBins "name" -- )</TT>
        </DT>
        <DD>
          Creates a <TT>ficl-wordlist</TT> with the specified number of hash table bins, binds it to the name, and associates the semantics of <TT>vocabulary</TT> with it (replaces the top wid in the
          search order list with its own wid when executed)
        </DD>
        <DT>
          <A name="ficlwordlist"></A><TT>ficl-wordlist&nbsp;&nbsp; ( nBins -- wid )</TT>
        </DT>
        <DD>
          Creates a wordlist with the specified number of hash table bins, and leaves the address of the wordlist on the stack. A <TT>ficl-wordlist</TT> behaves exactly as a regular wordlist, but it
          may search faster depending on the number of bins chosen and the number of words it contains at search time. As implemented in ficl, a wordlist is single threaded by default. <TT>
          ficl-named-wordlist</TT> takes a name for the wordlist and creates a word that pushes the <TT>wid</TT>. This is by contrast to <TT>VOCABULARY</TT>, which also has a name, but replaces the
          top of the search order with its <TT>wid</TT>.
        </DD>
        <DT>
          <A name="ficlforgetwid"></A><TT>forget-wid&nbsp;&nbsp; ( wid -- )</TT>
        </DT>
        <DD>
          Iterates through the specified wordlist and unlinks all definitions whose xt addresses are greater than or equal to the value of <TT>HERE</TT>, the dictionary fill pointer.&nbsp;
        </DD>
        <DT>
          <A name="ficlhide"></A><TT>hide&nbsp;&nbsp; ( -- current-wid-was )</TT>
        </DT>
        <DD>
          Push the <TT>hidden</TT> wordlist onto the search order, and set it as the current compile wordlist (unsing <TT>ficl-set-current</TT>). Leaves the previous compile wordlist ID. I use this
          word to hide implementation factor words that have low reuse potential so that they don't clutter the default wordlist. To undo the effect of hide, execute&nbsp; <B><TT>previous
          set-current</TT></B>
        </DD>
        <DT>
          <A name="ficlhidden"></A><TT>hidden&nbsp;&nbsp; ( -- wid )</TT>
        </DT>
        <DD>
          Wordlist for storing implementation factors of ficl provided words. To see what's in there, try:&nbsp; <B><TT>hide words previous set-current</TT></B>
        </DD>
        <DT>
          <A name="wid-get-name"></A><TT>wid-get-name&nbsp;&nbsp; ( wid -- c-addr u )</TT>
        </DT>
        <DD>
          Ficl wordlists (2.05 and later) have a name property that can be assigned. This is used by <TT>ORDER</TT> to list the names of wordlists in the search order.&nbsp;
        </DD>
        <DT>
          <A name="wid-set-name"></A><TT>wid-set-name&nbsp;&nbsp; ( c-addr wid -- )</TT>
        </DT>
        <DD>
          Ficl wordlists (2.05 and later) have a name property that can be assigned. This is used by <TT>ORDER</TT> to list the names of wordlists in the search order. The name is assumed to be a \0
          terminated string (C style), which conveniently is how Ficl stores word names.&nbsp; See softwords/softcore.fr definition of <TT>brand-wordlist</TT>&nbsp;
        </DD>
        <DT>
          <A name="wid-set-super"></A><TT>wid-set-super&nbsp;&nbsp; ( wid -- )</TT>
        </DT>
        <DD>
          Ficl wordlists have a parent wordlist pointer that is not specified in standard Forth. Ficl initializes this pointer to NULL whenever it creates a wordlist, so it ordinarily has no effect.
          This word sets the parent pointer to the wordlist specified on the top of the stack. Ficl's implementation of <TT>SEARCH-WORDLIST</TT> will chain backward through the parent link of the
          wordlist when searching. This simplifies Ficl's object model in that the search order does not need to reflect an object's class hierarchy when searching for a method. It is possible to
          implement Ficl object syntax in strict ANS Forth, but method finders need to manipulate the search order explicitly.
        </DD>
      </DL>
      <H3>
        <A name="exuser"></A>User variables
      </H3>
      <DL>
        <DT>
          <TT>user&nbsp;&nbsp; ( -- ) name</TT>
        </DT>
        <DD>
          Create a user variable with the given name. User variables are virtual machine local. Each VM allocates a fixed amount of storage for them. You can change the maximum number of user
          variables allowed by defining FICL_USER_CELLS on your compiiler's command line. Default is 16 user cells. User variables behave like <TT>VARIABLE</TT>s in all other respects (you use @ and
          ! on them, for example). Example:
        </DD>
        <DD>
          <DL>
            <DD>
              <TT>user current-class</TT>
            </DD>
            <DD>
              <TT>0 current-class !</TT>
            </DD>
          </DL>
        </DD>
      </DL>
      <H3>
        <A name="exmisc"></A>Miscellaneous
      </H3>
      <DL>
        <DT>
          <TT>-roll&nbsp;&nbsp; ( xu xu-1 ... x0 u -- x0 xu-1 ... x1 )&nbsp;</TT>
        </DT>
        <DD>
          Rotate u+1 items on top of the stack after removing u. Rotation is in the opposite sense to <TT>ROLL</TT>
        </DD>
      </DL>
      <DL>
        <DT>
          <A name="minusrot"></A><TT>-rot&nbsp;&nbsp; ( a b c -- c a b )</TT>
        </DT>
        <DD>
          Rotate the top three stack entries, moving the top of stack to third place. I like to think of this as <TT>1<SUP>1</SUP>/<SUB>2</SUB>swap</TT> because it's good for tucking a single cell
          value behind a cell-pair (like an object).&nbsp;
        </DD>
      </DL>
      <DL>
        <DT>
          <TT>.env&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          List all environment variables of the system
        </DD>
        <DT>
          <TT>.hash&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          List hash table performance statistics of the wordlist that's first in the search order
        </DD>
        <DT>
          <TT>.ver&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          Display ficl version ID
        </DD>
        <DT>
          <TT>&gt;name&nbsp;&nbsp; ( xt -- c-addr u )</TT>
        </DT>
        <DD>
          Convert a word's execution token into the address and length of its name
        </DD>
        <DT>
          <TT>body&gt;&nbsp;&nbsp; ( a-addr -- xt )</TT>
        </DT>
        <DD>
          Reverses the effect of <TT>CORE</TT> word <TT>&gt;body</TT> (converts a parameter field address to an execution token)
        </DD>
        <DT>
          <TT>compile-only</TT>
        </DT>
        <DD>
          Mark the most recently defined word as being executable only while in compile state. Many <TT>immediate</TT> words have this property.
        </DD>
        <DT>
          <TT>empty&nbsp;&nbsp; ( -- )</TT>&nbsp;
        </DT>
        <DD>
          Empty the parameter stack
        </DD>
        <DT>
          <TT>endif</TT>
        </DT>
        <DD>
          Synonym for <TT>THEN</TT>
        </DD>
        <DT>
          <A name="last-word"></A><TT>last-word&nbsp;&nbsp; ( -- xt )</TT>
        </DT>
        <DD>
          Pushes the xt address of the most recently defined word. This applies to colon definitions, constants, variables, and words that use <TT>create</TT>. You can print the name of the most
          recently defined word with&nbsp;
        </DD>
        <DD>
          <B><TT>last-word &gt;name type</TT>&nbsp;</B>
        </DD>
        <DT>
          <TT>parse-word&nbsp;&nbsp; ( &lt;spaces&gt;name -- c-addr u )</TT>
        </DT>
        <DD>
          Skip leading spaces and parse name delimited by a space. c-addr is the address within the input buffer and u is the length of the selected string. If the parse area is empty, the resulting
          string has a zero length. (From the Standard)
        </DD>
        <DT>
          <A name="qfetch"></A><TT>q@&nbsp;&nbsp; ( addr -- x )</TT>
        </DT>
        <DD>
          Fetch a 32 bit quantity from the specified address
        </DD>
        <DT>
          <A name="qbang"></A><TT>q!&nbsp;&nbsp; ( x addr -- )</TT>
        </DT>
        <DD>
          Store a 32 bit quantity to the specified address&nbsp;
        </DD>
        <DT>
          <TT>w@&nbsp;&nbsp; ( addr -- x )</TT>
        </DT>
        <DD>
          Fetch a 16 bit quantity from the specified address
        </DD>
        <DT>
          <TT>w!&nbsp;&nbsp; ( x addr -- )</TT>
        </DT>
        <DD>
          Store a 16 bit quantity to the specified address (the low 16 bits of the given value)
        </DD>
        <DT>
          <A name="xdot"></A><TT>x.&nbsp;&nbsp; ( x -- )</TT>
        </DT>
        <DD>
          Pop and display the value in hex format, regardless of the current value of <TT>BASE</TT>
        </DD>
      </DL>
      <H3>
        <A name="exficlwin"></A>Extra words defined in testmain.c (Win32 and POSIX versions)
      </H3>
      <DL>
        <DT>
          <TT>break&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          Does nothing - just a handy place to set a debugger breakpoint
        </DD>
        <DT>
          <TT>cd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( "directory-name&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Executes the Win32 chdir() function, changing the program's logged directory.
        </DD>
        <DT>
          <A name="clock"></A><TT>clock&nbsp;&nbsp; ( -- now )</TT>
        </DT>
        <DD>
          Wrapper for the ANSI C clock() function. Returns the number of clock ticks elapsed since process start.
        </DD>
        <DT>
          <A name="clockspersec"></A><TT>clocks/sec&nbsp;&nbsp; ( -- clocks_per_sec )</TT>
        </DT>
        <DD>
          Pushes the number of ticks in a second as returned by <TT>clock</TT>
        </DD>
        <DT>
          <A name="ficlload"></A><TT>load&nbsp;&nbsp;&nbsp; ( "filename&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Opens the Forth source file specified and loads it one line at a time, like <TT>INCLUDED (FILE)</TT>
        </DD>
        <DT>
          <TT>pwd&nbsp;&nbsp;&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          Prints the current working directory as set by <TT>cd</TT>
        </DD>
        <DT>
          <TT>system&nbsp; ( "command&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Issues a command to a shell; implemented with the Win32 system() call.
        </DD>
        <DT>
          <TT>spewhash&nbsp;&nbsp; ( "filename&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Dumps all threads of the current compilation wordlist to the specified text file. This was useful when I thought there might be some point in attempting to optimize the hash function. I no
          longer harbor those illusions.
        </DD>
      </DL>
      <H3>
        Words defined in FiclWin only
      </H3>
      <DL>
        <DT>
          <TT>!oreg&nbsp;&nbsp; ( c -- )</TT>
        </DT>
        <DD>
          Set the value of the simulated LED register as specified (0..255)
        </DD>
        <DT>
          <TT>@ireg&nbsp;&nbsp; ( -- c )</TT>
        </DT>
        <DD>
          Gets the value of the simulated switch block (0..255)
        </DD>
        <DT>
          <TT>!dac&nbsp;&nbsp;&nbsp; ( c -- )</TT>
        </DT>
        <DD>
          Sets the value of the bargraph control as specified. Valid values range from 0..255
        </DD>
        <DT>
          <TT>@adc&nbsp;&nbsp;&nbsp; ( -- c )</TT>
        </DT>
        <DD>
          Fetches the current position of the slider control. Range is 0..255
        </DD>
        <DT>
          <TT>status"&nbsp;&nbsp; ( "ccc&lt;quote&gt;" -- )</TT>
        </DT>
        <DD>
          Set the mainframe window's status line to the text specified, up to the first trailing quote character.
        </DD>
        <DT>
          <A name="ficlms"></A><TT><A href="http://www.taygeta.com/forth/dpans10.htm#10.6.2.1905">ms</A>&nbsp;&nbsp; ( u -- )</TT>
        </DT>
        <DD>
          Causes the running virtual machine to sleep() for the number of milliseconds specified by the top-of-stack value.
        </DD>
      </DL>
    </DIV>
  </BODY>
</HTML>

